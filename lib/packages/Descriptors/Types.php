<?php
//namespace ;

/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Exception\TApplicationException;


final class TTableType {
  const HDFS_TABLE = 0;
  const HBASE_TABLE = 1;
  static public $__names = array(
    0 => 'HDFS_TABLE',
    1 => 'HBASE_TABLE',
  );
}

final class THdfsFileFormat {
  const TEXT = 0;
  const LZO_TEXT = 1;
  const RC_FILE = 2;
  const SEQUENCE_FILE = 3;
  const TREVNI = 4;
  static public $__names = array(
    0 => 'TEXT',
    1 => 'LZO_TEXT',
    2 => 'RC_FILE',
    3 => 'SEQUENCE_FILE',
    4 => 'TREVNI',
  );
}

final class THdfsCompression {
  const NONE = 0;
  const DEFAULTS = 1;
  const GZIP = 2;
  const BZIP2 = 3;
  const SNAPPY = 4;
  const SNAPPY_BLOCKED = 5;
  static public $__names = array(
    0 => 'NONE',
    1 => 'DEFAULTS',
    2 => 'GZIP',
    3 => 'BZIP2',
    4 => 'SNAPPY',
    5 => 'SNAPPY_BLOCKED',
  );
}

class TSlotDescriptor {
  static $_TSPEC;

  public $id = null;
  public $parent = null;
  public $slotType = null;
  public $columnPos = null;
  public $byteOffset = null;
  public $nullIndicatorByte = null;
  public $nullIndicatorBit = null;
  public $slotIdx = null;
  public $isMaterialized = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'parent',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'slotType',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'columnPos',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'byteOffset',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'nullIndicatorByte',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'nullIndicatorBit',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'slotIdx',
          'type' => TType::I32,
          ),
        10 => array(
          'var' => 'isMaterialized',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['parent'])) {
        $this->parent = $vals['parent'];
      }
      if (isset($vals['slotType'])) {
        $this->slotType = $vals['slotType'];
      }
      if (isset($vals['columnPos'])) {
        $this->columnPos = $vals['columnPos'];
      }
      if (isset($vals['byteOffset'])) {
        $this->byteOffset = $vals['byteOffset'];
      }
      if (isset($vals['nullIndicatorByte'])) {
        $this->nullIndicatorByte = $vals['nullIndicatorByte'];
      }
      if (isset($vals['nullIndicatorBit'])) {
        $this->nullIndicatorBit = $vals['nullIndicatorBit'];
      }
      if (isset($vals['slotIdx'])) {
        $this->slotIdx = $vals['slotIdx'];
      }
      if (isset($vals['isMaterialized'])) {
        $this->isMaterialized = $vals['isMaterialized'];
      }
    }
  }

  public function getName() {
    return 'TSlotDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->parent);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->slotType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->columnPos);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->byteOffset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->nullIndicatorByte);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->nullIndicatorBit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->slotIdx);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isMaterialized);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TSlotDescriptor');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I32, 1);
      $xfer += $output->writeI32($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parent !== null) {
      $xfer += $output->writeFieldBegin('parent', TType::I32, 2);
      $xfer += $output->writeI32($this->parent);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->slotType !== null) {
      $xfer += $output->writeFieldBegin('slotType', TType::I32, 3);
      $xfer += $output->writeI32($this->slotType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnPos !== null) {
      $xfer += $output->writeFieldBegin('columnPos', TType::I32, 4);
      $xfer += $output->writeI32($this->columnPos);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byteOffset !== null) {
      $xfer += $output->writeFieldBegin('byteOffset', TType::I32, 5);
      $xfer += $output->writeI32($this->byteOffset);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nullIndicatorByte !== null) {
      $xfer += $output->writeFieldBegin('nullIndicatorByte', TType::I32, 6);
      $xfer += $output->writeI32($this->nullIndicatorByte);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nullIndicatorBit !== null) {
      $xfer += $output->writeFieldBegin('nullIndicatorBit', TType::I32, 7);
      $xfer += $output->writeI32($this->nullIndicatorBit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->slotIdx !== null) {
      $xfer += $output->writeFieldBegin('slotIdx', TType::I32, 9);
      $xfer += $output->writeI32($this->slotIdx);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isMaterialized !== null) {
      $xfer += $output->writeFieldBegin('isMaterialized', TType::BOOL, 10);
      $xfer += $output->writeBool($this->isMaterialized);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THdfsPartition {
  static $_TSPEC;

  public $lineDelim = null;
  public $fieldDelim = null;
  public $collectionDelim = null;
  public $mapKeyDelim = null;
  public $escapeChar = null;
  public $fileFormat = null;
  public $partitionKeyExprs = null;
  public $blockSize = null;
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'lineDelim',
          'type' => TType::BYTE,
          ),
        2 => array(
          'var' => 'fieldDelim',
          'type' => TType::BYTE,
          ),
        3 => array(
          'var' => 'collectionDelim',
          'type' => TType::BYTE,
          ),
        4 => array(
          'var' => 'mapKeyDelim',
          'type' => TType::BYTE,
          ),
        5 => array(
          'var' => 'escapeChar',
          'type' => TType::BYTE,
          ),
        6 => array(
          'var' => 'fileFormat',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'partitionKeyExprs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TExpr',
            ),
          ),
        8 => array(
          'var' => 'blockSize',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['lineDelim'])) {
        $this->lineDelim = $vals['lineDelim'];
      }
      if (isset($vals['fieldDelim'])) {
        $this->fieldDelim = $vals['fieldDelim'];
      }
      if (isset($vals['collectionDelim'])) {
        $this->collectionDelim = $vals['collectionDelim'];
      }
      if (isset($vals['mapKeyDelim'])) {
        $this->mapKeyDelim = $vals['mapKeyDelim'];
      }
      if (isset($vals['escapeChar'])) {
        $this->escapeChar = $vals['escapeChar'];
      }
      if (isset($vals['fileFormat'])) {
        $this->fileFormat = $vals['fileFormat'];
      }
      if (isset($vals['partitionKeyExprs'])) {
        $this->partitionKeyExprs = $vals['partitionKeyExprs'];
      }
      if (isset($vals['blockSize'])) {
        $this->blockSize = $vals['blockSize'];
      }
      if (isset($vals['compression'])) {
        $this->compression = $vals['compression'];
      }
    }
  }

  public function getName() {
    return 'THdfsPartition';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->lineDelim);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->fieldDelim);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->collectionDelim);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->mapKeyDelim);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->escapeChar);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->fileFormat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::LST) {
            $this->partitionKeyExprs = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \TExpr();
              $xfer += $elem5->read($input);
              $this->partitionKeyExprs []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->blockSize);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->compression);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THdfsPartition');
    if ($this->lineDelim !== null) {
      $xfer += $output->writeFieldBegin('lineDelim', TType::BYTE, 1);
      $xfer += $output->writeByte($this->lineDelim);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fieldDelim !== null) {
      $xfer += $output->writeFieldBegin('fieldDelim', TType::BYTE, 2);
      $xfer += $output->writeByte($this->fieldDelim);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->collectionDelim !== null) {
      $xfer += $output->writeFieldBegin('collectionDelim', TType::BYTE, 3);
      $xfer += $output->writeByte($this->collectionDelim);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mapKeyDelim !== null) {
      $xfer += $output->writeFieldBegin('mapKeyDelim', TType::BYTE, 4);
      $xfer += $output->writeByte($this->mapKeyDelim);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->escapeChar !== null) {
      $xfer += $output->writeFieldBegin('escapeChar', TType::BYTE, 5);
      $xfer += $output->writeByte($this->escapeChar);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileFormat !== null) {
      $xfer += $output->writeFieldBegin('fileFormat', TType::I32, 6);
      $xfer += $output->writeI32($this->fileFormat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionKeyExprs !== null) {
      if (!is_array($this->partitionKeyExprs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionKeyExprs', TType::LST, 7);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitionKeyExprs));
        {
          foreach ($this->partitionKeyExprs as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->blockSize !== null) {
      $xfer += $output->writeFieldBegin('blockSize', TType::I32, 8);
      $xfer += $output->writeI32($this->blockSize);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->compression !== null) {
      $xfer += $output->writeFieldBegin('compression', TType::I32, 9);
      $xfer += $output->writeI32($this->compression);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THdfsTable {
  static $_TSPEC;

  public $hdfsBaseDir = null;
  public $partitionKeyNames = null;
  public $nullPartitionKeyValue = null;
  public $partitions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'hdfsBaseDir',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'partitionKeyNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'nullPartitionKeyValue',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'partitions',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\THdfsPartition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hdfsBaseDir'])) {
        $this->hdfsBaseDir = $vals['hdfsBaseDir'];
      }
      if (isset($vals['partitionKeyNames'])) {
        $this->partitionKeyNames = $vals['partitionKeyNames'];
      }
      if (isset($vals['nullPartitionKeyValue'])) {
        $this->nullPartitionKeyValue = $vals['nullPartitionKeyValue'];
      }
      if (isset($vals['partitions'])) {
        $this->partitions = $vals['partitions'];
      }
    }
  }

  public function getName() {
    return 'THdfsTable';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hdfsBaseDir);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->partitionKeyNames = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $xfer += $input->readString($elem12);
              $this->partitionKeyNames []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nullPartitionKeyValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->partitions = array();
            $_size13 = 0;
            $_ktype14 = 0;
            $_vtype15 = 0;
            $xfer += $input->readMapBegin($_ktype14, $_vtype15, $_size13);
            for ($_i17 = 0; $_i17 < $_size13; ++$_i17)
            {
              $key18 = 0;
              $val19 = new \THdfsPartition();
              $xfer += $input->readI64($key18);
              $val19 = new \THdfsPartition();
              $xfer += $val19->read($input);
              $this->partitions[$key18] = $val19;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THdfsTable');
    if ($this->hdfsBaseDir !== null) {
      $xfer += $output->writeFieldBegin('hdfsBaseDir', TType::STRING, 1);
      $xfer += $output->writeString($this->hdfsBaseDir);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionKeyNames !== null) {
      if (!is_array($this->partitionKeyNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionKeyNames', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->partitionKeyNames));
        {
          foreach ($this->partitionKeyNames as $iter20)
          {
            $xfer += $output->writeString($iter20);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nullPartitionKeyValue !== null) {
      $xfer += $output->writeFieldBegin('nullPartitionKeyValue', TType::STRING, 3);
      $xfer += $output->writeString($this->nullPartitionKeyValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitions !== null) {
      if (!is_array($this->partitions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitions', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::I64, TType::STRUCT, count($this->partitions));
        {
          foreach ($this->partitions as $kiter21 => $viter22)
          {
            $xfer += $output->writeI64($kiter21);
            $xfer += $viter22->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseTable {
  static $_TSPEC;

  public $tableName = null;
  public $families = null;
  public $qualifiers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'families',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'qualifiers',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['families'])) {
        $this->families = $vals['families'];
      }
      if (isset($vals['qualifiers'])) {
        $this->qualifiers = $vals['qualifiers'];
      }
    }
  }

  public function getName() {
    return 'THBaseTable';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->families = array();
            $_size23 = 0;
            $_etype26 = 0;
            $xfer += $input->readListBegin($_etype26, $_size23);
            for ($_i27 = 0; $_i27 < $_size23; ++$_i27)
            {
              $elem28 = null;
              $xfer += $input->readString($elem28);
              $this->families []= $elem28;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->qualifiers = array();
            $_size29 = 0;
            $_etype32 = 0;
            $xfer += $input->readListBegin($_etype32, $_size29);
            for ($_i33 = 0; $_i33 < $_size29; ++$_i33)
            {
              $elem34 = null;
              $xfer += $input->readString($elem34);
              $this->qualifiers []= $elem34;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseTable');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->families !== null) {
      if (!is_array($this->families)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('families', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->families));
        {
          foreach ($this->families as $iter35)
          {
            $xfer += $output->writeString($iter35);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qualifiers !== null) {
      if (!is_array($this->qualifiers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('qualifiers', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->qualifiers));
        {
          foreach ($this->qualifiers as $iter36)
          {
            $xfer += $output->writeString($iter36);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTableDescriptor {
  static $_TSPEC;

  public $id = null;
  public $tableType = null;
  public $numCols = null;
  public $numClusteringCols = null;
  public $hdfsTable = null;
  public $hbaseTable = null;
  public $tableName = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'tableType',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'numCols',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'numClusteringCols',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'hdfsTable',
          'type' => TType::STRUCT,
          'class' => '\THdfsTable',
          ),
        6 => array(
          'var' => 'hbaseTable',
          'type' => TType::STRUCT,
          'class' => '\THBaseTable',
          ),
        7 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['tableType'])) {
        $this->tableType = $vals['tableType'];
      }
      if (isset($vals['numCols'])) {
        $this->numCols = $vals['numCols'];
      }
      if (isset($vals['numClusteringCols'])) {
        $this->numClusteringCols = $vals['numClusteringCols'];
      }
      if (isset($vals['hdfsTable'])) {
        $this->hdfsTable = $vals['hdfsTable'];
      }
      if (isset($vals['hbaseTable'])) {
        $this->hbaseTable = $vals['hbaseTable'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'TTableDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->tableType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numCols);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numClusteringCols);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->hdfsTable = new \THdfsTable();
            $xfer += $this->hdfsTable->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->hbaseTable = new \THBaseTable();
            $xfer += $this->hbaseTable->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTableDescriptor');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I32, 1);
      $xfer += $output->writeI32($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableType !== null) {
      $xfer += $output->writeFieldBegin('tableType', TType::I32, 2);
      $xfer += $output->writeI32($this->tableType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numCols !== null) {
      $xfer += $output->writeFieldBegin('numCols', TType::I32, 3);
      $xfer += $output->writeI32($this->numCols);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numClusteringCols !== null) {
      $xfer += $output->writeFieldBegin('numClusteringCols', TType::I32, 4);
      $xfer += $output->writeI32($this->numClusteringCols);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hdfsTable !== null) {
      if (!is_object($this->hdfsTable)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hdfsTable', TType::STRUCT, 5);
      $xfer += $this->hdfsTable->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hbaseTable !== null) {
      if (!is_object($this->hbaseTable)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hbaseTable', TType::STRUCT, 6);
      $xfer += $this->hbaseTable->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 7);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 8);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTupleDescriptor {
  static $_TSPEC;

  public $id = null;
  public $byteSize = null;
  public $numNullBytes = null;
  public $tableId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'byteSize',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'numNullBytes',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'tableId',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['byteSize'])) {
        $this->byteSize = $vals['byteSize'];
      }
      if (isset($vals['numNullBytes'])) {
        $this->numNullBytes = $vals['numNullBytes'];
      }
      if (isset($vals['tableId'])) {
        $this->tableId = $vals['tableId'];
      }
    }
  }

  public function getName() {
    return 'TTupleDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->byteSize);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numNullBytes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->tableId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTupleDescriptor');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I32, 1);
      $xfer += $output->writeI32($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byteSize !== null) {
      $xfer += $output->writeFieldBegin('byteSize', TType::I32, 2);
      $xfer += $output->writeI32($this->byteSize);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numNullBytes !== null) {
      $xfer += $output->writeFieldBegin('numNullBytes', TType::I32, 3);
      $xfer += $output->writeI32($this->numNullBytes);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableId !== null) {
      $xfer += $output->writeFieldBegin('tableId', TType::I32, 4);
      $xfer += $output->writeI32($this->tableId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TDescriptorTable {
  static $_TSPEC;

  public $slotDescriptors = null;
  public $tupleDescriptors = null;
  public $tableDescriptors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'slotDescriptors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TSlotDescriptor',
            ),
          ),
        2 => array(
          'var' => 'tupleDescriptors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TTupleDescriptor',
            ),
          ),
        3 => array(
          'var' => 'tableDescriptors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TTableDescriptor',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['slotDescriptors'])) {
        $this->slotDescriptors = $vals['slotDescriptors'];
      }
      if (isset($vals['tupleDescriptors'])) {
        $this->tupleDescriptors = $vals['tupleDescriptors'];
      }
      if (isset($vals['tableDescriptors'])) {
        $this->tableDescriptors = $vals['tableDescriptors'];
      }
    }
  }

  public function getName() {
    return 'TDescriptorTable';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->slotDescriptors = array();
            $_size37 = 0;
            $_etype40 = 0;
            $xfer += $input->readListBegin($_etype40, $_size37);
            for ($_i41 = 0; $_i41 < $_size37; ++$_i41)
            {
              $elem42 = null;
              $elem42 = new \TSlotDescriptor();
              $xfer += $elem42->read($input);
              $this->slotDescriptors []= $elem42;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tupleDescriptors = array();
            $_size43 = 0;
            $_etype46 = 0;
            $xfer += $input->readListBegin($_etype46, $_size43);
            for ($_i47 = 0; $_i47 < $_size43; ++$_i47)
            {
              $elem48 = null;
              $elem48 = new \TTupleDescriptor();
              $xfer += $elem48->read($input);
              $this->tupleDescriptors []= $elem48;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->tableDescriptors = array();
            $_size49 = 0;
            $_etype52 = 0;
            $xfer += $input->readListBegin($_etype52, $_size49);
            for ($_i53 = 0; $_i53 < $_size49; ++$_i53)
            {
              $elem54 = null;
              $elem54 = new \TTableDescriptor();
              $xfer += $elem54->read($input);
              $this->tableDescriptors []= $elem54;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TDescriptorTable');
    if ($this->slotDescriptors !== null) {
      if (!is_array($this->slotDescriptors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('slotDescriptors', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->slotDescriptors));
        {
          foreach ($this->slotDescriptors as $iter55)
          {
            $xfer += $iter55->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tupleDescriptors !== null) {
      if (!is_array($this->tupleDescriptors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tupleDescriptors', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tupleDescriptors));
        {
          foreach ($this->tupleDescriptors as $iter56)
          {
            $xfer += $iter56->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableDescriptors !== null) {
      if (!is_array($this->tableDescriptors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tableDescriptors', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tableDescriptors));
        {
          foreach ($this->tableDescriptors as $iter57)
          {
            $xfer += $iter57->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


