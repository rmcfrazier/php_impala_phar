<?php
//namespace ;

/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Exception\TApplicationException;


final class TExprNodeType {
  const AGG_EXPR = 0;
  const ARITHMETIC_EXPR = 1;
  const BINARY_PRED = 2;
  const BOOL_LITERAL = 3;
  const CASE_EXPR = 4;
  const CAST_EXPR = 5;
  const COMPOUND_PRED = 6;
  const DATE_LITERAL = 7;
  const FLOAT_LITERAL = 8;
  const FUNCTION_CALL = 9;
  const INT_LITERAL = 10;
  const IN_PRED = 11;
  const IS_NULL_PRED = 12;
  const LIKE_PRED = 13;
  const LITERAL_PRED = 14;
  const NULL_LITERAL = 15;
  const SLOT_REF = 16;
  const STRING_LITERAL = 17;
  static public $__names = array(
    0 => 'AGG_EXPR',
    1 => 'ARITHMETIC_EXPR',
    2 => 'BINARY_PRED',
    3 => 'BOOL_LITERAL',
    4 => 'CASE_EXPR',
    5 => 'CAST_EXPR',
    6 => 'COMPOUND_PRED',
    7 => 'DATE_LITERAL',
    8 => 'FLOAT_LITERAL',
    9 => 'FUNCTION_CALL',
    10 => 'INT_LITERAL',
    11 => 'IN_PRED',
    12 => 'IS_NULL_PRED',
    13 => 'LIKE_PRED',
    14 => 'LITERAL_PRED',
    15 => 'NULL_LITERAL',
    16 => 'SLOT_REF',
    17 => 'STRING_LITERAL',
  );
}

final class TAggregationOp {
  const INVALID = 0;
  const COUNT = 1;
  const MAX = 2;
  const DISTINCT_PC = 3;
  const MERGE_PC = 4;
  const DISTINCT_PCSA = 5;
  const MERGE_PCSA = 6;
  const MIN = 7;
  const SUM = 8;
  static public $__names = array(
    0 => 'INVALID',
    1 => 'COUNT',
    2 => 'MAX',
    3 => 'DISTINCT_PC',
    4 => 'MERGE_PC',
    5 => 'DISTINCT_PCSA',
    6 => 'MERGE_PCSA',
    7 => 'MIN',
    8 => 'SUM',
  );
}

class TAggregateExpr {
  static $_TSPEC;

  public $is_star = null;
  public $is_distinct = null;
  public $op = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'is_star',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'is_distinct',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'op',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['is_star'])) {
        $this->is_star = $vals['is_star'];
      }
      if (isset($vals['is_distinct'])) {
        $this->is_distinct = $vals['is_distinct'];
      }
      if (isset($vals['op'])) {
        $this->op = $vals['op'];
      }
    }
  }

  public function getName() {
    return 'TAggregateExpr';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->is_star);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->is_distinct);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->op);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TAggregateExpr');
    if ($this->is_star !== null) {
      $xfer += $output->writeFieldBegin('is_star', TType::BOOL, 1);
      $xfer += $output->writeBool($this->is_star);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->is_distinct !== null) {
      $xfer += $output->writeFieldBegin('is_distinct', TType::BOOL, 2);
      $xfer += $output->writeBool($this->is_distinct);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->op !== null) {
      $xfer += $output->writeFieldBegin('op', TType::I32, 3);
      $xfer += $output->writeI32($this->op);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TBoolLiteral {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TBoolLiteral';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TBoolLiteral');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::BOOL, 1);
      $xfer += $output->writeBool($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCaseExpr {
  static $_TSPEC;

  public $has_case_expr = null;
  public $has_else_expr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'has_case_expr',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'has_else_expr',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['has_case_expr'])) {
        $this->has_case_expr = $vals['has_case_expr'];
      }
      if (isset($vals['has_else_expr'])) {
        $this->has_else_expr = $vals['has_else_expr'];
      }
    }
  }

  public function getName() {
    return 'TCaseExpr';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->has_case_expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->has_else_expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCaseExpr');
    if ($this->has_case_expr !== null) {
      $xfer += $output->writeFieldBegin('has_case_expr', TType::BOOL, 1);
      $xfer += $output->writeBool($this->has_case_expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->has_else_expr !== null) {
      $xfer += $output->writeFieldBegin('has_else_expr', TType::BOOL, 2);
      $xfer += $output->writeBool($this->has_else_expr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TDateLiteral {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TDateLiteral';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TDateLiteral');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I64, 1);
      $xfer += $output->writeI64($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TFloatLiteral {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TFloatLiteral';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TFloatLiteral');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::DOUBLE, 1);
      $xfer += $output->writeDouble($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TIntLiteral {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TIntLiteral';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TIntLiteral');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I64, 1);
      $xfer += $output->writeI64($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TInPredicate {
  static $_TSPEC;

  public $is_not_in = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'is_not_in',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['is_not_in'])) {
        $this->is_not_in = $vals['is_not_in'];
      }
    }
  }

  public function getName() {
    return 'TInPredicate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->is_not_in);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TInPredicate');
    if ($this->is_not_in !== null) {
      $xfer += $output->writeFieldBegin('is_not_in', TType::BOOL, 1);
      $xfer += $output->writeBool($this->is_not_in);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TIsNullPredicate {
  static $_TSPEC;

  public $is_not_null = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'is_not_null',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['is_not_null'])) {
        $this->is_not_null = $vals['is_not_null'];
      }
    }
  }

  public function getName() {
    return 'TIsNullPredicate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->is_not_null);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TIsNullPredicate');
    if ($this->is_not_null !== null) {
      $xfer += $output->writeFieldBegin('is_not_null', TType::BOOL, 1);
      $xfer += $output->writeBool($this->is_not_null);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TLikePredicate {
  static $_TSPEC;

  public $escape_char = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'escape_char',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['escape_char'])) {
        $this->escape_char = $vals['escape_char'];
      }
    }
  }

  public function getName() {
    return 'TLikePredicate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->escape_char);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TLikePredicate');
    if ($this->escape_char !== null) {
      $xfer += $output->writeFieldBegin('escape_char', TType::STRING, 1);
      $xfer += $output->writeString($this->escape_char);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TLiteralPredicate {
  static $_TSPEC;

  public $value = null;
  public $is_null = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'is_null',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['is_null'])) {
        $this->is_null = $vals['is_null'];
      }
    }
  }

  public function getName() {
    return 'TLiteralPredicate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->is_null);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TLiteralPredicate');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::BOOL, 1);
      $xfer += $output->writeBool($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->is_null !== null) {
      $xfer += $output->writeFieldBegin('is_null', TType::BOOL, 2);
      $xfer += $output->writeBool($this->is_null);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TSlotRef {
  static $_TSPEC;

  public $slot_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'slot_id',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['slot_id'])) {
        $this->slot_id = $vals['slot_id'];
      }
    }
  }

  public function getName() {
    return 'TSlotRef';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->slot_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TSlotRef');
    if ($this->slot_id !== null) {
      $xfer += $output->writeFieldBegin('slot_id', TType::I32, 1);
      $xfer += $output->writeI32($this->slot_id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStringLiteral {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TStringLiteral';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStringLiteral');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 1);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TExprNode {
  static $_TSPEC;

  public $node_type = null;
  public $type = null;
  public $opcode = null;
  public $num_children = null;
  public $agg_expr = null;
  public $bool_literal = null;
  public $case_expr = null;
  public $date_literal = null;
  public $float_literal = null;
  public $int_literal = null;
  public $in_predicate = null;
  public $is_null_pred = null;
  public $like_pred = null;
  public $literal_pred = null;
  public $slot_ref = null;
  public $string_literal = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'opcode',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'num_children',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'agg_expr',
          'type' => TType::STRUCT,
          'class' => '\TAggregateExpr',
          ),
        6 => array(
          'var' => 'bool_literal',
          'type' => TType::STRUCT,
          'class' => '\TBoolLiteral',
          ),
        7 => array(
          'var' => 'case_expr',
          'type' => TType::STRUCT,
          'class' => '\TCaseExpr',
          ),
        8 => array(
          'var' => 'date_literal',
          'type' => TType::STRUCT,
          'class' => '\TDateLiteral',
          ),
        9 => array(
          'var' => 'float_literal',
          'type' => TType::STRUCT,
          'class' => '\TFloatLiteral',
          ),
        10 => array(
          'var' => 'int_literal',
          'type' => TType::STRUCT,
          'class' => '\TIntLiteral',
          ),
        11 => array(
          'var' => 'in_predicate',
          'type' => TType::STRUCT,
          'class' => '\TInPredicate',
          ),
        12 => array(
          'var' => 'is_null_pred',
          'type' => TType::STRUCT,
          'class' => '\TIsNullPredicate',
          ),
        13 => array(
          'var' => 'like_pred',
          'type' => TType::STRUCT,
          'class' => '\TLikePredicate',
          ),
        14 => array(
          'var' => 'literal_pred',
          'type' => TType::STRUCT,
          'class' => '\TLiteralPredicate',
          ),
        15 => array(
          'var' => 'slot_ref',
          'type' => TType::STRUCT,
          'class' => '\TSlotRef',
          ),
        16 => array(
          'var' => 'string_literal',
          'type' => TType::STRUCT,
          'class' => '\TStringLiteral',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_type'])) {
        $this->node_type = $vals['node_type'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['opcode'])) {
        $this->opcode = $vals['opcode'];
      }
      if (isset($vals['num_children'])) {
        $this->num_children = $vals['num_children'];
      }
      if (isset($vals['agg_expr'])) {
        $this->agg_expr = $vals['agg_expr'];
      }
      if (isset($vals['bool_literal'])) {
        $this->bool_literal = $vals['bool_literal'];
      }
      if (isset($vals['case_expr'])) {
        $this->case_expr = $vals['case_expr'];
      }
      if (isset($vals['date_literal'])) {
        $this->date_literal = $vals['date_literal'];
      }
      if (isset($vals['float_literal'])) {
        $this->float_literal = $vals['float_literal'];
      }
      if (isset($vals['int_literal'])) {
        $this->int_literal = $vals['int_literal'];
      }
      if (isset($vals['in_predicate'])) {
        $this->in_predicate = $vals['in_predicate'];
      }
      if (isset($vals['is_null_pred'])) {
        $this->is_null_pred = $vals['is_null_pred'];
      }
      if (isset($vals['like_pred'])) {
        $this->like_pred = $vals['like_pred'];
      }
      if (isset($vals['literal_pred'])) {
        $this->literal_pred = $vals['literal_pred'];
      }
      if (isset($vals['slot_ref'])) {
        $this->slot_ref = $vals['slot_ref'];
      }
      if (isset($vals['string_literal'])) {
        $this->string_literal = $vals['string_literal'];
      }
    }
  }

  public function getName() {
    return 'TExprNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->node_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->opcode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_children);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->agg_expr = new \TAggregateExpr();
            $xfer += $this->agg_expr->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->bool_literal = new \TBoolLiteral();
            $xfer += $this->bool_literal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->case_expr = new \TCaseExpr();
            $xfer += $this->case_expr->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->date_literal = new \TDateLiteral();
            $xfer += $this->date_literal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->float_literal = new \TFloatLiteral();
            $xfer += $this->float_literal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->int_literal = new \TIntLiteral();
            $xfer += $this->int_literal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRUCT) {
            $this->in_predicate = new \TInPredicate();
            $xfer += $this->in_predicate->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRUCT) {
            $this->is_null_pred = new \TIsNullPredicate();
            $xfer += $this->is_null_pred->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRUCT) {
            $this->like_pred = new \TLikePredicate();
            $xfer += $this->like_pred->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::STRUCT) {
            $this->literal_pred = new \TLiteralPredicate();
            $xfer += $this->literal_pred->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRUCT) {
            $this->slot_ref = new \TSlotRef();
            $xfer += $this->slot_ref->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRUCT) {
            $this->string_literal = new \TStringLiteral();
            $xfer += $this->string_literal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TExprNode');
    if ($this->node_type !== null) {
      $xfer += $output->writeFieldBegin('node_type', TType::I32, 1);
      $xfer += $output->writeI32($this->node_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->opcode !== null) {
      $xfer += $output->writeFieldBegin('opcode', TType::I32, 3);
      $xfer += $output->writeI32($this->opcode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_children !== null) {
      $xfer += $output->writeFieldBegin('num_children', TType::I32, 4);
      $xfer += $output->writeI32($this->num_children);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->agg_expr !== null) {
      if (!is_object($this->agg_expr)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('agg_expr', TType::STRUCT, 5);
      $xfer += $this->agg_expr->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bool_literal !== null) {
      if (!is_object($this->bool_literal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bool_literal', TType::STRUCT, 6);
      $xfer += $this->bool_literal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->case_expr !== null) {
      if (!is_object($this->case_expr)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('case_expr', TType::STRUCT, 7);
      $xfer += $this->case_expr->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->date_literal !== null) {
      if (!is_object($this->date_literal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('date_literal', TType::STRUCT, 8);
      $xfer += $this->date_literal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->float_literal !== null) {
      if (!is_object($this->float_literal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('float_literal', TType::STRUCT, 9);
      $xfer += $this->float_literal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->int_literal !== null) {
      if (!is_object($this->int_literal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('int_literal', TType::STRUCT, 10);
      $xfer += $this->int_literal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->in_predicate !== null) {
      if (!is_object($this->in_predicate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('in_predicate', TType::STRUCT, 11);
      $xfer += $this->in_predicate->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->is_null_pred !== null) {
      if (!is_object($this->is_null_pred)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('is_null_pred', TType::STRUCT, 12);
      $xfer += $this->is_null_pred->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->like_pred !== null) {
      if (!is_object($this->like_pred)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('like_pred', TType::STRUCT, 13);
      $xfer += $this->like_pred->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->literal_pred !== null) {
      if (!is_object($this->literal_pred)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('literal_pred', TType::STRUCT, 14);
      $xfer += $this->literal_pred->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->slot_ref !== null) {
      if (!is_object($this->slot_ref)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('slot_ref', TType::STRUCT, 15);
      $xfer += $this->slot_ref->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->string_literal !== null) {
      if (!is_object($this->string_literal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('string_literal', TType::STRUCT, 16);
      $xfer += $this->string_literal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TExpr {
  static $_TSPEC;

  public $nodes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nodes',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TExprNode',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nodes'])) {
        $this->nodes = $vals['nodes'];
      }
    }
  }

  public function getName() {
    return 'TExpr';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->nodes = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \TExprNode();
              $xfer += $elem5->read($input);
              $this->nodes []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TExpr');
    if ($this->nodes !== null) {
      if (!is_array($this->nodes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nodes', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->nodes));
        {
          foreach ($this->nodes as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


