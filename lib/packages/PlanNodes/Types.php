<?php
//namespace ;

/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Exception\TApplicationException;


final class TPlanNodeType {
  const HDFS_SCAN_NODE = 0;
  const HBASE_SCAN_NODE = 1;
  const HASH_JOIN_NODE = 2;
  const AGGREGATION_NODE = 3;
  const SORT_NODE = 4;
  const EXCHANGE_NODE = 5;
  const MERGE_NODE = 6;
  static public $__names = array(
    0 => 'HDFS_SCAN_NODE',
    1 => 'HBASE_SCAN_NODE',
    2 => 'HASH_JOIN_NODE',
    3 => 'AGGREGATION_NODE',
    4 => 'SORT_NODE',
    5 => 'EXCHANGE_NODE',
    6 => 'MERGE_NODE',
  );
}

final class TJoinOp {
  const INNER_JOIN = 0;
  const LEFT_OUTER_JOIN = 1;
  const LEFT_SEMI_JOIN = 2;
  const RIGHT_OUTER_JOIN = 3;
  const FULL_OUTER_JOIN = 4;
  static public $__names = array(
    0 => 'INNER_JOIN',
    1 => 'LEFT_OUTER_JOIN',
    2 => 'LEFT_SEMI_JOIN',
    3 => 'RIGHT_OUTER_JOIN',
    4 => 'FULL_OUTER_JOIN',
  );
}

class THdfsFileSplit {
  static $_TSPEC;

  public $path = null;
  public $offset = null;
  public $length = null;
  public $partition_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'offset',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'length',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'partition_id',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['offset'])) {
        $this->offset = $vals['offset'];
      }
      if (isset($vals['length'])) {
        $this->length = $vals['length'];
      }
      if (isset($vals['partition_id'])) {
        $this->partition_id = $vals['partition_id'];
      }
    }
  }

  public function getName() {
    return 'THdfsFileSplit';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->offset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->length);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->partition_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THdfsFileSplit');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->offset !== null) {
      $xfer += $output->writeFieldBegin('offset', TType::I64, 2);
      $xfer += $output->writeI64($this->offset);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->length !== null) {
      $xfer += $output->writeFieldBegin('length', TType::I64, 3);
      $xfer += $output->writeI64($this->length);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partition_id !== null) {
      $xfer += $output->writeFieldBegin('partition_id', TType::I64, 4);
      $xfer += $output->writeI64($this->partition_id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseKeyRange {
  static $_TSPEC;

  public $startKey = null;
  public $stopKey = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'startKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'stopKey',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['startKey'])) {
        $this->startKey = $vals['startKey'];
      }
      if (isset($vals['stopKey'])) {
        $this->stopKey = $vals['stopKey'];
      }
    }
  }

  public function getName() {
    return 'THBaseKeyRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseKeyRange');
    if ($this->startKey !== null) {
      $xfer += $output->writeFieldBegin('startKey', TType::STRING, 1);
      $xfer += $output->writeString($this->startKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopKey !== null) {
      $xfer += $output->writeFieldBegin('stopKey', TType::STRING, 2);
      $xfer += $output->writeString($this->stopKey);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TScanRange {
  static $_TSPEC;

  public $hdfs_file_split = null;
  public $hbase_key_range = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'hdfs_file_split',
          'type' => TType::STRUCT,
          'class' => '\THdfsFileSplit',
          ),
        2 => array(
          'var' => 'hbase_key_range',
          'type' => TType::STRUCT,
          'class' => '\THBaseKeyRange',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hdfs_file_split'])) {
        $this->hdfs_file_split = $vals['hdfs_file_split'];
      }
      if (isset($vals['hbase_key_range'])) {
        $this->hbase_key_range = $vals['hbase_key_range'];
      }
    }
  }

  public function getName() {
    return 'TScanRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->hdfs_file_split = new \THdfsFileSplit();
            $xfer += $this->hdfs_file_split->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->hbase_key_range = new \THBaseKeyRange();
            $xfer += $this->hbase_key_range->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TScanRange');
    if ($this->hdfs_file_split !== null) {
      if (!is_object($this->hdfs_file_split)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hdfs_file_split', TType::STRUCT, 1);
      $xfer += $this->hdfs_file_split->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hbase_key_range !== null) {
      if (!is_object($this->hbase_key_range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hbase_key_range', TType::STRUCT, 2);
      $xfer += $this->hbase_key_range->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THdfsScanNode {
  static $_TSPEC;

  public $tuple_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tuple_id',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tuple_id'])) {
        $this->tuple_id = $vals['tuple_id'];
      }
    }
  }

  public function getName() {
    return 'THdfsScanNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->tuple_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THdfsScanNode');
    if ($this->tuple_id !== null) {
      $xfer += $output->writeFieldBegin('tuple_id', TType::I32, 1);
      $xfer += $output->writeI32($this->tuple_id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseFilter {
  static $_TSPEC;

  public $family = null;
  public $qualifier = null;
  public $op_ordinal = null;
  public $filter_constant = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'family',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'qualifier',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'op_ordinal',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'filter_constant',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['family'])) {
        $this->family = $vals['family'];
      }
      if (isset($vals['qualifier'])) {
        $this->qualifier = $vals['qualifier'];
      }
      if (isset($vals['op_ordinal'])) {
        $this->op_ordinal = $vals['op_ordinal'];
      }
      if (isset($vals['filter_constant'])) {
        $this->filter_constant = $vals['filter_constant'];
      }
    }
  }

  public function getName() {
    return 'THBaseFilter';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->family);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->qualifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->op_ordinal);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter_constant);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseFilter');
    if ($this->family !== null) {
      $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
      $xfer += $output->writeString($this->family);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qualifier !== null) {
      $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 2);
      $xfer += $output->writeString($this->qualifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->op_ordinal !== null) {
      $xfer += $output->writeFieldBegin('op_ordinal', TType::I32, 3);
      $xfer += $output->writeI32($this->op_ordinal);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter_constant !== null) {
      $xfer += $output->writeFieldBegin('filter_constant', TType::STRING, 4);
      $xfer += $output->writeString($this->filter_constant);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THBaseScanNode {
  static $_TSPEC;

  public $tuple_id = null;
  public $table_name = null;
  public $filters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tuple_id',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'filters',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\THBaseFilter',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tuple_id'])) {
        $this->tuple_id = $vals['tuple_id'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['filters'])) {
        $this->filters = $vals['filters'];
      }
    }
  }

  public function getName() {
    return 'THBaseScanNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->tuple_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->filters = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \THBaseFilter();
              $xfer += $elem5->read($input);
              $this->filters []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THBaseScanNode');
    if ($this->tuple_id !== null) {
      $xfer += $output->writeFieldBegin('tuple_id', TType::I32, 1);
      $xfer += $output->writeI32($this->tuple_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filters !== null) {
      if (!is_array($this->filters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('filters', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->filters));
        {
          foreach ($this->filters as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TEqJoinCondition {
  static $_TSPEC;

  public $left = null;
  public $right = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'left',
          'type' => TType::STRUCT,
          'class' => '\TExpr',
          ),
        2 => array(
          'var' => 'right',
          'type' => TType::STRUCT,
          'class' => '\TExpr',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['left'])) {
        $this->left = $vals['left'];
      }
      if (isset($vals['right'])) {
        $this->right = $vals['right'];
      }
    }
  }

  public function getName() {
    return 'TEqJoinCondition';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->left = new \TExpr();
            $xfer += $this->left->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->right = new \TExpr();
            $xfer += $this->right->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TEqJoinCondition');
    if ($this->left !== null) {
      if (!is_object($this->left)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('left', TType::STRUCT, 1);
      $xfer += $this->left->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->right !== null) {
      if (!is_object($this->right)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('right', TType::STRUCT, 2);
      $xfer += $this->right->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THashJoinNode {
  static $_TSPEC;

  public $join_op = null;
  public $eq_join_conjuncts = null;
  public $other_join_conjuncts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'join_op',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'eq_join_conjuncts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TEqJoinCondition',
            ),
          ),
        3 => array(
          'var' => 'other_join_conjuncts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TExpr',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['join_op'])) {
        $this->join_op = $vals['join_op'];
      }
      if (isset($vals['eq_join_conjuncts'])) {
        $this->eq_join_conjuncts = $vals['eq_join_conjuncts'];
      }
      if (isset($vals['other_join_conjuncts'])) {
        $this->other_join_conjuncts = $vals['other_join_conjuncts'];
      }
    }
  }

  public function getName() {
    return 'THashJoinNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->join_op);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->eq_join_conjuncts = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $elem12 = new \TEqJoinCondition();
              $xfer += $elem12->read($input);
              $this->eq_join_conjuncts []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->other_join_conjuncts = array();
            $_size13 = 0;
            $_etype16 = 0;
            $xfer += $input->readListBegin($_etype16, $_size13);
            for ($_i17 = 0; $_i17 < $_size13; ++$_i17)
            {
              $elem18 = null;
              $elem18 = new \TExpr();
              $xfer += $elem18->read($input);
              $this->other_join_conjuncts []= $elem18;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THashJoinNode');
    if ($this->join_op !== null) {
      $xfer += $output->writeFieldBegin('join_op', TType::I32, 1);
      $xfer += $output->writeI32($this->join_op);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eq_join_conjuncts !== null) {
      if (!is_array($this->eq_join_conjuncts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('eq_join_conjuncts', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->eq_join_conjuncts));
        {
          foreach ($this->eq_join_conjuncts as $iter19)
          {
            $xfer += $iter19->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->other_join_conjuncts !== null) {
      if (!is_array($this->other_join_conjuncts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('other_join_conjuncts', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->other_join_conjuncts));
        {
          foreach ($this->other_join_conjuncts as $iter20)
          {
            $xfer += $iter20->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TAggregationNode {
  static $_TSPEC;

  public $grouping_exprs = null;
  public $aggregate_exprs = null;
  public $agg_tuple_id = null;
  public $need_finalize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'grouping_exprs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TExpr',
            ),
          ),
        2 => array(
          'var' => 'aggregate_exprs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TExpr',
            ),
          ),
        3 => array(
          'var' => 'agg_tuple_id',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'need_finalize',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['grouping_exprs'])) {
        $this->grouping_exprs = $vals['grouping_exprs'];
      }
      if (isset($vals['aggregate_exprs'])) {
        $this->aggregate_exprs = $vals['aggregate_exprs'];
      }
      if (isset($vals['agg_tuple_id'])) {
        $this->agg_tuple_id = $vals['agg_tuple_id'];
      }
      if (isset($vals['need_finalize'])) {
        $this->need_finalize = $vals['need_finalize'];
      }
    }
  }

  public function getName() {
    return 'TAggregationNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->grouping_exprs = array();
            $_size21 = 0;
            $_etype24 = 0;
            $xfer += $input->readListBegin($_etype24, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $elem26 = null;
              $elem26 = new \TExpr();
              $xfer += $elem26->read($input);
              $this->grouping_exprs []= $elem26;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->aggregate_exprs = array();
            $_size27 = 0;
            $_etype30 = 0;
            $xfer += $input->readListBegin($_etype30, $_size27);
            for ($_i31 = 0; $_i31 < $_size27; ++$_i31)
            {
              $elem32 = null;
              $elem32 = new \TExpr();
              $xfer += $elem32->read($input);
              $this->aggregate_exprs []= $elem32;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->agg_tuple_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->need_finalize);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TAggregationNode');
    if ($this->grouping_exprs !== null) {
      if (!is_array($this->grouping_exprs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('grouping_exprs', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->grouping_exprs));
        {
          foreach ($this->grouping_exprs as $iter33)
          {
            $xfer += $iter33->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->aggregate_exprs !== null) {
      if (!is_array($this->aggregate_exprs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('aggregate_exprs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->aggregate_exprs));
        {
          foreach ($this->aggregate_exprs as $iter34)
          {
            $xfer += $iter34->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->agg_tuple_id !== null) {
      $xfer += $output->writeFieldBegin('agg_tuple_id', TType::I32, 3);
      $xfer += $output->writeI32($this->agg_tuple_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->need_finalize !== null) {
      $xfer += $output->writeFieldBegin('need_finalize', TType::BOOL, 4);
      $xfer += $output->writeBool($this->need_finalize);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TSortNode {
  static $_TSPEC;

  public $ordering_exprs = null;
  public $is_asc_order = null;
  public $use_top_n = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ordering_exprs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TExpr',
            ),
          ),
        2 => array(
          'var' => 'is_asc_order',
          'type' => TType::LST,
          'etype' => TType::BOOL,
          'elem' => array(
            'type' => TType::BOOL,
            ),
          ),
        3 => array(
          'var' => 'use_top_n',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ordering_exprs'])) {
        $this->ordering_exprs = $vals['ordering_exprs'];
      }
      if (isset($vals['is_asc_order'])) {
        $this->is_asc_order = $vals['is_asc_order'];
      }
      if (isset($vals['use_top_n'])) {
        $this->use_top_n = $vals['use_top_n'];
      }
    }
  }

  public function getName() {
    return 'TSortNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->ordering_exprs = array();
            $_size35 = 0;
            $_etype38 = 0;
            $xfer += $input->readListBegin($_etype38, $_size35);
            for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
            {
              $elem40 = null;
              $elem40 = new \TExpr();
              $xfer += $elem40->read($input);
              $this->ordering_exprs []= $elem40;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->is_asc_order = array();
            $_size41 = 0;
            $_etype44 = 0;
            $xfer += $input->readListBegin($_etype44, $_size41);
            for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
            {
              $elem46 = null;
              $xfer += $input->readBool($elem46);
              $this->is_asc_order []= $elem46;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->use_top_n);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TSortNode');
    if ($this->ordering_exprs !== null) {
      if (!is_array($this->ordering_exprs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ordering_exprs', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->ordering_exprs));
        {
          foreach ($this->ordering_exprs as $iter47)
          {
            $xfer += $iter47->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->is_asc_order !== null) {
      if (!is_array($this->is_asc_order)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('is_asc_order', TType::LST, 2);
      {
        $output->writeListBegin(TType::BOOL, count($this->is_asc_order));
        {
          foreach ($this->is_asc_order as $iter48)
          {
            $xfer += $output->writeBool($iter48);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->use_top_n !== null) {
      $xfer += $output->writeFieldBegin('use_top_n', TType::BOOL, 3);
      $xfer += $output->writeBool($this->use_top_n);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TMergeNode {
  static $_TSPEC;

  public $result_expr_lists = null;
  public $const_expr_lists = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'result_expr_lists',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\TExpr',
              ),
            ),
          ),
        2 => array(
          'var' => 'const_expr_lists',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\TExpr',
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['result_expr_lists'])) {
        $this->result_expr_lists = $vals['result_expr_lists'];
      }
      if (isset($vals['const_expr_lists'])) {
        $this->const_expr_lists = $vals['const_expr_lists'];
      }
    }
  }

  public function getName() {
    return 'TMergeNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->result_expr_lists = array();
            $_size49 = 0;
            $_etype52 = 0;
            $xfer += $input->readListBegin($_etype52, $_size49);
            for ($_i53 = 0; $_i53 < $_size49; ++$_i53)
            {
              $elem54 = null;
              $elem54 = array();
              $_size55 = 0;
              $_etype58 = 0;
              $xfer += $input->readListBegin($_etype58, $_size55);
              for ($_i59 = 0; $_i59 < $_size55; ++$_i59)
              {
                $elem60 = null;
                $elem60 = new \TExpr();
                $xfer += $elem60->read($input);
                $elem54 []= $elem60;
              }
              $xfer += $input->readListEnd();
              $this->result_expr_lists []= $elem54;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->const_expr_lists = array();
            $_size61 = 0;
            $_etype64 = 0;
            $xfer += $input->readListBegin($_etype64, $_size61);
            for ($_i65 = 0; $_i65 < $_size61; ++$_i65)
            {
              $elem66 = null;
              $elem66 = array();
              $_size67 = 0;
              $_etype70 = 0;
              $xfer += $input->readListBegin($_etype70, $_size67);
              for ($_i71 = 0; $_i71 < $_size67; ++$_i71)
              {
                $elem72 = null;
                $elem72 = new \TExpr();
                $xfer += $elem72->read($input);
                $elem66 []= $elem72;
              }
              $xfer += $input->readListEnd();
              $this->const_expr_lists []= $elem66;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TMergeNode');
    if ($this->result_expr_lists !== null) {
      if (!is_array($this->result_expr_lists)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('result_expr_lists', TType::LST, 1);
      {
        $output->writeListBegin(TType::LST, count($this->result_expr_lists));
        {
          foreach ($this->result_expr_lists as $iter73)
          {
            {
              $output->writeListBegin(TType::STRUCT, count($iter73));
              {
                foreach ($iter73 as $iter74)
                {
                  $xfer += $iter74->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->const_expr_lists !== null) {
      if (!is_array($this->const_expr_lists)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('const_expr_lists', TType::LST, 2);
      {
        $output->writeListBegin(TType::LST, count($this->const_expr_lists));
        {
          foreach ($this->const_expr_lists as $iter75)
          {
            {
              $output->writeListBegin(TType::STRUCT, count($iter75));
              {
                foreach ($iter75 as $iter76)
                {
                  $xfer += $iter76->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TPlanNode {
  static $_TSPEC;

  public $node_id = null;
  public $node_type = null;
  public $num_children = null;
  public $limit = null;
  public $row_tuples = null;
  public $nullable_tuples = null;
  public $conjuncts = null;
  public $compact_data = null;
  public $hdfs_scan_node = null;
  public $hbase_scan_node = null;
  public $hash_join_node = null;
  public $agg_node = null;
  public $sort_node = null;
  public $merge_node = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_id',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'node_type',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'num_children',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'limit',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'row_tuples',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        6 => array(
          'var' => 'nullable_tuples',
          'type' => TType::LST,
          'etype' => TType::BOOL,
          'elem' => array(
            'type' => TType::BOOL,
            ),
          ),
        7 => array(
          'var' => 'conjuncts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TExpr',
            ),
          ),
        8 => array(
          'var' => 'compact_data',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'hdfs_scan_node',
          'type' => TType::STRUCT,
          'class' => '\THdfsScanNode',
          ),
        10 => array(
          'var' => 'hbase_scan_node',
          'type' => TType::STRUCT,
          'class' => '\THBaseScanNode',
          ),
        11 => array(
          'var' => 'hash_join_node',
          'type' => TType::STRUCT,
          'class' => '\THashJoinNode',
          ),
        12 => array(
          'var' => 'agg_node',
          'type' => TType::STRUCT,
          'class' => '\TAggregationNode',
          ),
        13 => array(
          'var' => 'sort_node',
          'type' => TType::STRUCT,
          'class' => '\TSortNode',
          ),
        14 => array(
          'var' => 'merge_node',
          'type' => TType::STRUCT,
          'class' => '\TMergeNode',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_id'])) {
        $this->node_id = $vals['node_id'];
      }
      if (isset($vals['node_type'])) {
        $this->node_type = $vals['node_type'];
      }
      if (isset($vals['num_children'])) {
        $this->num_children = $vals['num_children'];
      }
      if (isset($vals['limit'])) {
        $this->limit = $vals['limit'];
      }
      if (isset($vals['row_tuples'])) {
        $this->row_tuples = $vals['row_tuples'];
      }
      if (isset($vals['nullable_tuples'])) {
        $this->nullable_tuples = $vals['nullable_tuples'];
      }
      if (isset($vals['conjuncts'])) {
        $this->conjuncts = $vals['conjuncts'];
      }
      if (isset($vals['compact_data'])) {
        $this->compact_data = $vals['compact_data'];
      }
      if (isset($vals['hdfs_scan_node'])) {
        $this->hdfs_scan_node = $vals['hdfs_scan_node'];
      }
      if (isset($vals['hbase_scan_node'])) {
        $this->hbase_scan_node = $vals['hbase_scan_node'];
      }
      if (isset($vals['hash_join_node'])) {
        $this->hash_join_node = $vals['hash_join_node'];
      }
      if (isset($vals['agg_node'])) {
        $this->agg_node = $vals['agg_node'];
      }
      if (isset($vals['sort_node'])) {
        $this->sort_node = $vals['sort_node'];
      }
      if (isset($vals['merge_node'])) {
        $this->merge_node = $vals['merge_node'];
      }
    }
  }

  public function getName() {
    return 'TPlanNode';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->node_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->node_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_children);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->limit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->row_tuples = array();
            $_size77 = 0;
            $_etype80 = 0;
            $xfer += $input->readListBegin($_etype80, $_size77);
            for ($_i81 = 0; $_i81 < $_size77; ++$_i81)
            {
              $elem82 = null;
              $xfer += $input->readI32($elem82);
              $this->row_tuples []= $elem82;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->nullable_tuples = array();
            $_size83 = 0;
            $_etype86 = 0;
            $xfer += $input->readListBegin($_etype86, $_size83);
            for ($_i87 = 0; $_i87 < $_size83; ++$_i87)
            {
              $elem88 = null;
              $xfer += $input->readBool($elem88);
              $this->nullable_tuples []= $elem88;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::LST) {
            $this->conjuncts = array();
            $_size89 = 0;
            $_etype92 = 0;
            $xfer += $input->readListBegin($_etype92, $_size89);
            for ($_i93 = 0; $_i93 < $_size89; ++$_i93)
            {
              $elem94 = null;
              $elem94 = new \TExpr();
              $xfer += $elem94->read($input);
              $this->conjuncts []= $elem94;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->compact_data);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->hdfs_scan_node = new \THdfsScanNode();
            $xfer += $this->hdfs_scan_node->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->hbase_scan_node = new \THBaseScanNode();
            $xfer += $this->hbase_scan_node->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRUCT) {
            $this->hash_join_node = new \THashJoinNode();
            $xfer += $this->hash_join_node->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRUCT) {
            $this->agg_node = new \TAggregationNode();
            $xfer += $this->agg_node->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRUCT) {
            $this->sort_node = new \TSortNode();
            $xfer += $this->sort_node->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::STRUCT) {
            $this->merge_node = new \TMergeNode();
            $xfer += $this->merge_node->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TPlanNode');
    if ($this->node_id !== null) {
      $xfer += $output->writeFieldBegin('node_id', TType::I32, 1);
      $xfer += $output->writeI32($this->node_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->node_type !== null) {
      $xfer += $output->writeFieldBegin('node_type', TType::I32, 2);
      $xfer += $output->writeI32($this->node_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_children !== null) {
      $xfer += $output->writeFieldBegin('num_children', TType::I32, 3);
      $xfer += $output->writeI32($this->num_children);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->limit !== null) {
      $xfer += $output->writeFieldBegin('limit', TType::I64, 4);
      $xfer += $output->writeI64($this->limit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row_tuples !== null) {
      if (!is_array($this->row_tuples)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('row_tuples', TType::LST, 5);
      {
        $output->writeListBegin(TType::I32, count($this->row_tuples));
        {
          foreach ($this->row_tuples as $iter95)
          {
            $xfer += $output->writeI32($iter95);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nullable_tuples !== null) {
      if (!is_array($this->nullable_tuples)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nullable_tuples', TType::LST, 6);
      {
        $output->writeListBegin(TType::BOOL, count($this->nullable_tuples));
        {
          foreach ($this->nullable_tuples as $iter96)
          {
            $xfer += $output->writeBool($iter96);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->conjuncts !== null) {
      if (!is_array($this->conjuncts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conjuncts', TType::LST, 7);
      {
        $output->writeListBegin(TType::STRUCT, count($this->conjuncts));
        {
          foreach ($this->conjuncts as $iter97)
          {
            $xfer += $iter97->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->compact_data !== null) {
      $xfer += $output->writeFieldBegin('compact_data', TType::BOOL, 8);
      $xfer += $output->writeBool($this->compact_data);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hdfs_scan_node !== null) {
      if (!is_object($this->hdfs_scan_node)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hdfs_scan_node', TType::STRUCT, 9);
      $xfer += $this->hdfs_scan_node->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hbase_scan_node !== null) {
      if (!is_object($this->hbase_scan_node)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hbase_scan_node', TType::STRUCT, 10);
      $xfer += $this->hbase_scan_node->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hash_join_node !== null) {
      if (!is_object($this->hash_join_node)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hash_join_node', TType::STRUCT, 11);
      $xfer += $this->hash_join_node->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->agg_node !== null) {
      if (!is_object($this->agg_node)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('agg_node', TType::STRUCT, 12);
      $xfer += $this->agg_node->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sort_node !== null) {
      if (!is_object($this->sort_node)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sort_node', TType::STRUCT, 13);
      $xfer += $this->sort_node->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->merge_node !== null) {
      if (!is_object($this->merge_node)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('merge_node', TType::STRUCT, 14);
      $xfer += $this->merge_node->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TPlan {
  static $_TSPEC;

  public $nodes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nodes',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\TPlanNode',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nodes'])) {
        $this->nodes = $vals['nodes'];
      }
    }
  }

  public function getName() {
    return 'TPlan';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->nodes = array();
            $_size98 = 0;
            $_etype101 = 0;
            $xfer += $input->readListBegin($_etype101, $_size98);
            for ($_i102 = 0; $_i102 < $_size98; ++$_i102)
            {
              $elem103 = null;
              $elem103 = new \TPlanNode();
              $xfer += $elem103->read($input);
              $this->nodes []= $elem103;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TPlan');
    if ($this->nodes !== null) {
      if (!is_array($this->nodes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nodes', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->nodes));
        {
          foreach ($this->nodes as $iter104)
          {
            $xfer += $iter104->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


